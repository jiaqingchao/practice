如何计算时间和空间复杂度？
算法的验证 -- 随机数据生成器、对数器
写算法的哲学

**调bug步骤**
    
    1.通读程序
    2.输出中间值
    3.剪功能，从小到大定位bug


**如何写算法程序**
    
    1.由简单到复杂
        a.验证一步走一步
        b.多打印中间结果
    2.先局部后整体
        a.没思路时先细分
    3.先粗糙后精细
        a.变量更名
        b.语句合并
        c.边界处理

**如何验证你的算法是否正确?**

    1：肉眼观察
    2：产生足够多的随机样本
    3：用确定正确的算法计算样本结果（系统自带的）
    4：对比被验证的结果
        
**稳定性:** 

    不稳,有相同的数，排好序的数可能与和它相同的数互换位置，
    再工程上可能会有问题，如银行按年龄排序，但存储金额不同，
    使用不稳定排序，可能把存储少的和存储多的排的位置和银行逻辑不一致，就会有问题。

**java对象排序**
    
    对象排序一般要求稳定
    
**TimeSort**

    使用归并排序和二分插入排序
    

###### **简单排序：**

**1.选择排序（Selection）**

    最简单但是最没用的排序算法，也有优化空间
    基本不用，不稳
    时间复杂度 平均O(n^2)、最坏O(n^2)、最好O(n^2)
    空间复杂度 1
    稳定性 不稳

**2.冒泡排序**
    
    基本不用，太慢
    时间复杂度 平均O(n^2)、最坏O(n^2)、最好O(n)
    空间复杂度 1 
    稳定性 稳 
    
**3.插入排序**
    
    样本小且基本有序的时候效率比价高（常用于数据量不是特别大的排序）
    时间复杂度 平均O(n^2)、最坏O(n^2)、最好O(n)
    空间复杂度 1 
    稳定性 稳 
    
###### **复杂排序：**
    
**4.希尔排序**
    
    时间复杂度比较平均，中等程度的问题用可以接受时，可以使用
    时间复杂度 平均O(n^1.3)、最坏O(n^2)、最好O(n)
    空间复杂度 1 
    稳定性 不稳 
    
**5.归并排序**
    
    java和pyton用的排序都是归并排序(用的多)
    时间复杂度 平均O(n * log2n)、最坏O(n * log2n)、最好O(n * log2n)
    空间复杂度 O(n) 
    稳定性 稳 
    
**6.快速排序**    
    
    改进：荷兰国旗问题可以改成小等大三种，双轴快排
    Array.sort(pair insertion sort)
    时间复杂度 平均O(n * log2n)、最坏O(n^2)、最好O(n * log2n)
    空间复杂度 O(n) 
    稳定性 不稳 
    
###### **桶排序：**

**7.计数排序**  
    
    是非比较的排序
    适用于特定问题，也就是对数据有要求
    时间复杂度 平均O(n+k)、最坏O(n+k)、最好O(n+k)
    空间复杂度 O(n+k) 
    
**8.基数排序**  
    
    本质上是一种多关键字排序
    有低数优先，有高位优先
        LSD MSD(Least Significant Digit first)(Most ...)
        MSD属于分治的思想
    百度百科的程序有问题
        空间复杂的变高 *10
    适用于特定问题，也就是对数据有要求
    时间复杂度 平均O(n*k)、最坏O(n*k)、最好O(n*k)
    空间复杂度 O(n+k) 
    
    
**9.桶排序**  
        
    使用最多的是计数排序，其次是基数排序，原始的基本用不到，也很少人用
        
    把一定大小的值放在一个桶里，可以创建多个桶，
    然后把每个桶里的数使用归并排序，或者快速排序。
    时间      
        1.求最大最小值n
        2.通初始化n
        3.遍历装桶n
        4.桶内排序n/k*lg(n/k)*k
        5.结果输出n
        6.3n+k+n/k*lg(n/k)*k=
          3n+k+n*lg(n/k)约等于n=k
        7.最坏n方（一个桶）
        8，最好为n(n个桶，而且值排列均匀)
    空间 
        1.n+k
        2.但实际上空间做的最好的话，就只能用链表，
        时间就做不到最好
